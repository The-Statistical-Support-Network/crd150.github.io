<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>Lab 5: Spatial Autocorrelation</title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/cosmo.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<script src="site_libs/navigation-1.1/codefolding.js"></script>
<link href="site_libs/highlightjs-9.12.0/textmate.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>

<link rel="stylesheet" href="styles.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 51px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h2 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h3 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h4 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h5 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h6 {
  padding-top: 56px;
  margin-top: -56px;
}
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #ffffff;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  background: white;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->
<style type="text/css">
.code-folding-btn { margin-bottom: 4px; }
</style>



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row-fluid">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">CRD 150: Winter 2020</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Home</a>
</li>
<li>
  <a href="syllabus.html">Syllabus</a>
</li>
<li>
  <a href="hw_guidelines.html">Assignment Guidelines</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Labs/Assignments
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="lab1.html">Lab 1</a>
    </li>
    <li>
      <a href="lab2.html">Lab 2</a>
    </li>
    <li>
      <a href="lab3.html">Lab 3</a>
    </li>
    <li>
      <a href="lab4.html">Lab 4</a>
    </li>
    <li>
      <a href="lab5.html">Lab 5</a>
    </li>
    <li>
      <a href="lab6.html">Lab 6</a>
    </li>
    <li>
      <a href="lab7.html">Lab 7</a>
    </li>
    <li>
      <a href="lab8.html">Lab 8</a>
    </li>
    <li>
      <a href="lab9.html">Lab 9</a>
    </li>
    <li>
      <a href="qgis.html">Extra Lab - QGIS</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Other
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="eligible.html">Eligible Communities</a>
    </li>
    <li>
      <a href="ndata.html">Neighborhood Data Sources</a>
    </li>
    <li>
      <a href="bigopendata.html">Big and Open Data Sources</a>
    </li>
    <li>
      <a href="nhgis.html">Using NHGIS</a>
    </li>
    <li>
      <a href="policymap.html">Using PolicyMap</a>
    </li>
    <li>
      <a href="missingdata.html">Missing Data</a>
    </li>
    <li>
      <a href="georeferencing.html">Mapping Coordinates</a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">

<div class="btn-group pull-right">
<button type="button" class="btn btn-default btn-xs dropdown-toggle" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><span>Code</span> <span class="caret"></span></button>
<ul class="dropdown-menu" style="min-width: 50px;">
<li><a id="rmd-show-all-code" href="#">Show All Code</a></li>
<li><a id="rmd-hide-all-code" href="#">Hide All Code</a></li>
</ul>
</div>



<h1 class="title toc-ignore">Lab 5: Spatial Autocorrelation</h1>
<h3 class="subtitle"><h4 style="font-style:normal">
CRD 150 - Quantitative Methods in Community Research
</h4></h3>
<h4 class="author"><h4 style="font-style:normal">
Professor Noli Brazil
</h4></h4>
<h4 class="date"><h4 style="font-style:normal">
February 7, 2020
</h4></h4>

</div>


<style>
p.comment {
background-color: #DBDBDB;
padding: 10px;
border: 1px solid black;
margin-left: 25px;
border-radius: 5px;
font-style: italic;
}

.figure {
   margin-top: 20px;
   margin-bottom: 20px;
}

h1.title {
  font-weight: bold;
  font-family: Arial;  
}

h2.title {
  font-family: Arial;  
}

</style>
<style type="text/css">
#TOC {
  font-size: 13px;
  font-family: Arial;
}
</style>
<p><br />
</p>
<p>The objectives of the guide are as follows</p>
<ol style="list-style-type: decimal">
<li>Learn spatial operations on polygon data</li>
<li>Learn how to create a spatial weights matrix</li>
<li>Calculate global spatial autocorrelation</li>
</ol>
<p>This lab guide follows closely and supplements the material presented in Chapters 4.1 and 4.2 in the textbook <a href="https://geocompr.robinlovelace.net/">Geocomputation with R</a> (GWR) and Chapter 7 in the textbook <a href="">Geographic Information Analysis</a>.</p>
<p class="comment" , style="font-style:normal">
<strong>Assignment 5 is due by 11:59 pm, February 13th on Canvas.</strong> See <a href="https://crd150.github.io/hw_guidelines.html">here</a> for assignment guidelines. You must submit an <code>.Rmd</code> file and its associated <code>.html</code> file. Name the files: yourLastName_firstInitial_asgn05. For example: brazil_n_asgn05.
</p>
<div style="margin-bottom:25px;">

</div>
<div id="open-up-an-r-markdown-file" class="section level2">
<h2><strong>Open up an R Markdown file</strong></h2>
<p><br />
Download the <a href="https://raw.githubusercontent.com/crd150/data/master/labtemplate.Rmd">Lab template</a> into an appropriate folder on your hard drive (preferably, a folder named ‘Lab 5’), open it in R Studio, and type and run your code there. Change the title (“Lab 5”) and insert your name and date. Don’t change anything else inside the YAML (the stuff at the top in between the <code>---</code>). Also keep the grey chunk after the YAML. For a rundown on the use of R Markdown in labs, see <a href="https://crd150.github.io/lab1.html">Lab 1</a></p>
<div style="margin-bottom:25px;">

</div>
</div>
<div id="installing-and-loading-packages" class="section level2">
<h2><strong>Installing and loading packages</strong></h2>
<p><br />
You’ll need to install the following packages in R. You only need to do it once, so if you’ve already installed these packages, skip the code. Also, don’t put these <code>install.packages()</code> in your R Markdown document. Copy and paste the code in the R Console. We’ll talk about what these packages provide as their relevant functions come up in the guide</p>
<pre class="r"><code>install.packages(&quot;sp&quot;)
install.packages(&quot;rmapshaper&quot;)
install.packages(&quot;spdep&quot;)</code></pre>
<p>You’ll need to load the following packages. Unlike installing, you will always need to load packages whenever you start a new R session. You’ll also always need to use <code>library()</code> in your R Markdown file.</p>
<pre class="r"><code>library(tidyverse)
library(tidycensus)
library(sf)
library(tigris)
#you need to let R know to bring in the spatial data as sf objects
options(tigris_class = &quot;sf&quot;)
library(tmap)
library(rmapshaper)
library(sp)
library(spdep)</code></pre>
<div style="margin-bottom:25px;">

</div>
</div>
<div id="bringing-spatial-data-into-r" class="section level2">
<h2><strong>Bringing spatial data into R</strong></h2>
<p><br />
We will be working with census tract data on the foreign-born population in Sacramento city and the Sacramento metropolitan area. The following code is very similar to the code in <a href="https://crd150.github.io/lab4.html">Lab 4</a>, so we won’t dwell on the specifics. We first need to get foreign-born population data for California census tracts. Let’s use our best friends the Census API and the function <code>get_acs()</code>.</p>
<pre class="r"><code>census_api_key(&quot;YOUR API KEY GOES HERE&quot;)</code></pre>
<p>Then use <code>get_acs()</code> to bring in the data.</p>
<pre class="r"><code>ca.tracts &lt;- get_acs(geography = &quot;tract&quot;, 
              year = 2017,
              variables = c(fb = &quot;B05012_003&quot;, totp = &quot;B05012_001&quot;), 
              state = &quot;CA&quot;,
              survey = &quot;acs5&quot;,
              geometry = TRUE) %&gt;%
              select(-(moe)) %&gt;%
              spread(key = variable, value = estimate) %&gt;%
              mutate(pfb = fb/totp) %&gt;%
              select(GEOID, totp, pfb)</code></pre>
<p>Next, let’s bring in the Sacramento metropolitan area boundary using <code>core_based_statistical_areas()</code> from the <strong>tigris</strong> package.</p>
<pre class="r"><code>cb &lt;- core_based_statistical_areas(cb = TRUE, year=2017)
sac.metro &lt;- filter(cb, grepl(&quot;Sacramento&quot;, NAME))</code></pre>
<p>Finally, bring in the Sacramento city boundary using <code>places()</code>.</p>
<pre class="r"><code>pl &lt;- places(state = &quot;CA&quot;, cb = TRUE, year=2017)
sac.city &lt;- filter(pl, NAME == &quot;Sacramento&quot;)</code></pre>
<div style="margin-bottom:25px;">

</div>
</div>
<div id="spatial-data-wrangling" class="section level2">
<h2><strong>Spatial data wrangling</strong></h2>
<p><br />
A major goal in this lab is to compute the spatial autocorrelation of percent foreign born in the Sacramento metropolitan area. Before we can do this, we need to keep the tracts from <em>ca.tracts</em> that are in Sacramento. Easier said than done. Looking at the variables in the data frame <em>ca.tracts</em>, we find that there is no variable that indicates whether the tract belongs to the Sacramento metropolitan area. This includes the <em>GEOID</em>, which only provides state and county census IDs. In order to extract the Sacramento tracts, we need to do some data wrangling. However, not just any old data wrangling, but <em>spatial</em> data wrangling. Cue <a href="https://www.youtube.com/watch?v=cphNpqKpKc4">dangerous sounding music</a>.</p>
<p>In <a href="https://crd150.github.io/lab4.html">Lab 4</a>, we discovered that all of the nonspatial data wrangling techniques we learned in <a href="https://crd150.github.io/lab2.html">Lab 2</a> also apply to spatial data. However, spatial data have their own special set of wrangling operations. These functions modify spatial objects based on their location and shape. The <strong>sf</strong> package offers a suite of functions unique to wrangling spatial data. Most of these functions start out with the prefix <code>st_</code>. To see all of the functions, type in</p>
<pre class="r"><code>methods(class = &quot;sf&quot;)</code></pre>
<p>We won’t go through all of these functions as the list is quite extensive. You can take a look at Chapters 4 and 5 of GWR to see some examples of these functions. We’ll also go through spatial wrangling specific to points in Lab 6. But, let’s go through the more relevant ones for this lab guide and this class. The function we will be primarily using is <code>st_join()</code>.</p>
<div style="margin-bottom:25px;">

</div>
<div id="intersect" class="section level3">
<h3><strong>Intersect</strong></h3>
<p><br />
A common spatial data wrangling issue is to subset a set of spatial objects based on their location relative to another spatial object. In our case, we want to keep California tracts that are in the Sacramento metro area. Think of what were doing here as something similar to taking a cookie cutter shaped like the Sacramento metro area (in our case, the <strong>sf</strong> object <em>sac.metro</em>) and cutting out the metro area from our cookie dough of census tracts (<em>ca.tracts</em>). We can do this using the <code>st_join()</code> function</p>
<pre class="r"><code>sac.metro.tracts.int &lt;- st_join(x = ca.tracts, y = sac.metro, 
                               join = st_intersects, left=FALSE)</code></pre>
<p>The above code tells R to identify the polygons in <em>ca.tracts</em> that intersect with the polygon <em>sac.metro</em>. We indicate we want a polygon intersection by specifying <code>join = st_intersects</code>. The option <code>left=FALSE</code> tells R to eliminate the polygons from <em>ca.tracts</em> that do not intersect (make it <code>TRUE</code> and see what happens).</p>
<p>Mapping the border of the Sacramento metropolitan area <em>sac.metro</em> (in red) onto these cut out tracts (in blue), we get</p>
<pre class="r"><code>ggplot() + 
  geom_sf(data = sac.metro.tracts.int, fill = &quot;blue&quot;) +
  geom_sf(data = sac.metro, fill = NA, color = &quot;red&quot;)</code></pre>
<p><img src="lab5_files/figure-html/unnamed-chunk-10-1.png" /><!-- --></p>
<p>As a reminder, if you are getting the following error when you map</p>
<pre><code>---
Error in grid.Call(C_textBounds, as.graphicsAnnot(x$label), x$x, x$y,  : 
  polygon edge not found
---</code></pre>
<p>rerun the code. Keep rerunning it until the error does not come up.</p>
<p><br></p>
<p>The opposite of <code>st_intersects is st_disjoint</code>. If two geometries are disjoint, they do not intersect, and vice-versa. Replace <code>join = st_intersects</code> with <code>join = st_disjoin</code> and see what you get.</p>
<div style="margin-bottom:25px;">

</div>
</div>
<div id="within" class="section level3">
<h3><strong>Within</strong></h3>
<p><br />
Do you see an issue with the tracts <em>sac.metro.tracts.w</em>? Using <code>join = st_intersects</code> returns all tracts that <strong>intersect</strong> <em>sac.metro</em>, which include those that <strong>touch</strong> the metro’s boundary. No bueno. We can instead use the argument <code>join = st_within</code> to return tracts that are completely <em>within</em> the metro.</p>
<pre class="r"><code># subset ca.tracts to those in sac.metro
sac.metro.tracts.w &lt;- st_join(ca.tracts, sac.metro, join = st_within, left=FALSE)

ggplot() + 
    geom_sf(data = sac.metro.tracts.w, fill = &quot;blue&quot;) +
    geom_sf(data = sac.metro, fill = NA, color = &quot;red&quot;)</code></pre>
<p><img src="lab5_files/figure-html/unnamed-chunk-11-1.png" /><!-- --></p>
<p>Now it works!!! High Five o/ \o</p>
<p><br></p>
<p>If you look at the at <em>sac.metro.tracts.w</em>’s attribute table, you’ll see it includes all the variables from both <em>ca.tracts</em> and <em>sac.metro</em>. We don’t need these variables, so use <code>select()</code> to eliminate them. You’ll also notice that if variables share the same name, R will keep both and attach a <em>.x</em> and <em>.y</em> to the end. For example, <em>GEOID</em> was found in both <em>ca.tracts</em> and <em>sac.metro</em>, so R named one <em>GEOID.x</em> and the other that was merged in was named <em>GEOID.y</em>.</p>
<pre class="r"><code>names(sac.metro.tracts.w)</code></pre>
<pre><code>##  [1] &quot;GEOID.x&quot;  &quot;totp&quot;     &quot;pfb&quot;      &quot;CSAFP&quot;    &quot;CBSAFP&quot;   &quot;AFFGEOID&quot;
##  [7] &quot;GEOID.y&quot;  &quot;NAME&quot;     &quot;LSAD&quot;     &quot;ALAND&quot;    &quot;AWATER&quot;   &quot;geometry&quot;</code></pre>
<p>Keep the necessary variables and rename <em>GEOID.x</em> back to <em>GEOID</em>.</p>
<pre class="r"><code>sac.metro.tracts.w &lt;- sac.metro.tracts.w %&gt;%
      select(GEOID.x:pfb) %&gt;%
      rename(GEOID = &quot;GEOID.x&quot;)</code></pre>
<div style="margin-bottom:25px;">

</div>
</div>
<div id="clipping" class="section level3">
<h3><strong>Clipping</strong></h3>
<p><br />
Census tracts neatly fall within a metropolitan area’s boundary, as it does for counties. In other words, tracts don’t spill over. But, it does spill over for cities. The left diagram in Figure 1 is an example of a metro area in red and four tracts in black - all the tracts fall neatly into the metro boundary. In contrast, the right diagram is an example of a city on top of four tracts - one tract falls neatly inside (top left), but the other three spill out.</p>
<center>
<div class="figure">
<img src="example1.png" alt="Figure 1: Tracts falling in (Metro) and out (City) of boundaries" />
<p class="caption">Figure 1: Tracts falling in (Metro) and out (City) of boundaries</p>
</div>
</center>
<p>If we use <code>st_join()</code> with <code>st_within</code> for Sacramento city, we’ll produce the following plot</p>
<pre class="r"><code>sac.city.tracts.w = st_join(ca.tracts, sac.city, join = st_within, left=FALSE)
ggplot() + 
  geom_sf(data = sac.city.tracts.w, fill = &quot;blue&quot;) +
  geom_sf(data = sac.city, fill = NA, color = &quot;red&quot;) </code></pre>
<p><img src="lab5_files/figure-html/unnamed-chunk-14-1.png" /><!-- --></p>
<p>Can you guess what is going on here?</p>
<p>The blue polygons are the tracts we kept. You’ll notice that the city is empty around some of the edges of its boundary. In these cases, only portions of census tracts are within the boundary. <code>st_within</code> keeps tracts only if they are <em>completely within</em> the boundary. This is not good when tracts do not neatly fall within a boundary.</p>
<p>One way of dealing with this is to clip the portion of the tract that is inside the boundary. Clipping will keep just the portion of the tract inside the city boundary and discards the rest of the tract. We use the function <code>ms_clip()</code> which is in the <a href="https://cran.r-project.org/web/packages/rmapshaper/rmapshaper.pdf"><strong>rmapshaper</strong></a> package. In the code below, <code>target = ca.tracts</code> tells R to cut out <em>ca.tracts</em> using the <em>sac.city</em> boundaries.</p>
<pre class="r"><code>sac.city.tracts.c &lt;- ms_clip(target = ca.tracts, clip = sac.city, remove_slivers = TRUE)
ggplot() + 
  geom_sf(data = sac.city.tracts.c, fill = &quot;blue&quot;) +
  geom_sf(data = sac.city, fill = NA, color = &quot;red&quot;)</code></pre>
<p><img src="lab5_files/figure-html/unnamed-chunk-15-1.png" /><!-- --></p>
<p>Now, the city is filled in with tracts. To be clear what a clip is doing, Figure 2 shows a clip of the city example shown in Figure 1. With a clip, one tract is not clipped because it falls completely within the city (the top left tract). But, the other three are clipped - the portions that are within the boundary are kept (in blue), and the rest (with hash marks) are discarded from the map.</p>
<p>Because spatial data are not always precise, when you clip you’ll sometimes get unwanted <a href="https://en.wikipedia.org/wiki/Sliver_polygon">sliver polygons</a>. The argument <code>remove_slivers = TRUE</code> removes these slivers.</p>
<center>
<div class="figure">
<img src="clip.png" alt="Figure 2: Clipping tracts" />
<p class="caption">Figure 2: Clipping tracts</p>
</div>
</center>
<p>Sit back and reflect on what a clip is doing in terms of how it represents a city. When you clip a tract and present it as a neighborhood in Sacramento, what are you assuming about that tract? Do you think this assumption is correct? In what ways is the assumption is wrong?</p>
<p>The function <code>st_overlaps</code> us the opposite of <code>st_within</code>. Replace <code>join = st_within</code> with <code>join = st_overlaps</code> to see what this spatial operation produces. Play around with the other <code>st_</code> options and see what you get (type in <code>? st_join</code> to find all the options).</p>
<div style="margin-bottom:25px;">

</div>
</div>
<div id="calculate-area" class="section level3">
<h3><strong>Calculate area</strong></h3>
<p><br />
Another useful <code>st_</code> function is <code>st_area()</code>, which calculates the area of a polygon. You might need the area, for example, if you want to calculate the density of something (e.g. the number of residents, crimes or trees per meters squared). To calculate the area, just plug in your <strong>sf</strong> polygon object inside <code>st_area()</code>. Let’s find the area of <em>sac.city.tracts.w</em> and save it to a vector named <em>area</em></p>
<pre class="r"><code>area &lt;- st_area(sac.city.tracts.w)</code></pre>
<p>We find that the object <em>area</em> is of class <em>units</em></p>
<pre class="r"><code>class(area)</code></pre>
<pre><code>## [1] &quot;units&quot;</code></pre>
<p>And the area is in meters squared</p>
<pre class="r"><code>area</code></pre>
<pre><code>## Units: [m^2]
##  [1] 2327060.4 1512570.0 1463450.7  975098.4  866095.5  403388.1  498934.8
##  [8]  568070.9 1577872.0  667854.1  792757.7  794857.9 1745237.3 3055769.1
## [15] 3524130.8 1716995.0 1106144.0 1037844.3 1541582.0 2725701.6 1218553.7
## [22] 3223586.3  985428.8  935123.8 1283782.4  924861.0 2318445.4 2573269.0
## [29] 1252373.7 1156023.0 1654346.9  984307.2 1599634.0 2382303.0 2260735.9
## [36] 1196046.4 1260038.8 1269987.0 1428132.3 4903570.3 2435402.5 3412785.2
## [43] 2996367.5 2179371.0 1968398.2 1652402.6 1887810.5 1646038.0 1207871.4
## [50] 2028272.7 1905370.8 1625437.4 1646702.9 3771040.5 1780715.0 1712940.2
## [57]  952471.2 2055643.1 1874746.5 8905278.9 6242702.1 1297534.2 2813347.0
## [64] 3461723.5 3888061.8 2212860.6 3289682.0 3926262.4 2471415.6 5290734.2
## [71] 2863616.9 3885897.9 2662222.0 1961448.6 1048691.9  673306.7 1979080.9
## [78] 4829069.3 4444028.8 2190099.8 2228979.1 1951779.9 8185367.9 2714006.4
## [85] 1461023.8 1871953.7  705029.9 1179100.6</code></pre>
<p>Let’s convert it from type <em>units</em> to type <em>numeric</em> by using the function <code>as.numeric()</code> and save it back into <em>sac.city.tracts.w</em> using the <code>mutate()</code> function</p>
<pre class="r"><code>sac.city.tracts.w &lt;- mutate(sac.city.tracts.w, area = as.numeric(st_area(sac.city.tracts.w)))</code></pre>
<p>You should find that the variable <em>area</em> is now in your dataset.</p>
<pre class="r"><code>names(sac.city.tracts.w)</code></pre>
<pre><code>##  [1] &quot;GEOID.x&quot;  &quot;totp&quot;     &quot;pfb&quot;      &quot;STATEFP&quot;  &quot;PLACEFP&quot;  &quot;PLACENS&quot; 
##  [7] &quot;AFFGEOID&quot; &quot;GEOID.y&quot;  &quot;NAME&quot;     &quot;LSAD&quot;     &quot;ALAND&quot;    &quot;AWATER&quot;  
## [13] &quot;geometry&quot; &quot;area&quot;</code></pre>
<div style="margin-bottom:25px;">

</div>
</div>
</div>
<div id="sf-vs.sp-spatial-objects" class="section level2">
<h2><strong>sf vs. sp spatial objects</strong></h2>
<p><br />
So far, we’ve been using <strong>sf</strong> to represent spatial data in R. The traditional way of handling spatial data in R is to use the <strong>sp</strong> package, <strong>sf</strong>’s evil twin sister (actually, no, but almost). <strong>sp</strong> has been around since 2005, and thus has a rich ecosystem of tools built on top of it. However, it uses a rather complex data structure, which can make it challenging to use. <strong>sf</strong> is newer (first released in 2016) so it doesn’t have such a rich ecosystem. However, it’s much easier to use and fits in very naturally with the tidyverse.</p>
<p>The trend is gradually shifting towards the use of <strong>sf</strong> as the primary spatial package. We prefer <strong>sf</strong> over <strong>sp</strong> because it adheres to the tidy principles outlined in RDS, but because it is relatively new, <strong>sf</strong> is not wholly compatible with all of R’s spatial functions, particularly those that perform spatial data analysis, including calculating global measures of spatial correlation. In contrast, <strong>sp</strong> is compatible with most spatial functions. As such, we’ll need to convert <strong>sf</strong> objects to <strong>sp</strong> objects in some cases.</p>
<p>Use the <code>as()</code> function to convert <em>sac.metro.tracts.w</em> to an <strong>sp</strong> compatible object.</p>
<pre class="r"><code>#this function to R to convert the sf object to an sp, using &quot;Spatial&quot; to designate sp
sac.metro.tracts.sp &lt;- as(sac.metro.tracts.w, &quot;Spatial&quot;)</code></pre>
<p>Then use the <code>class()</code> function on the <strong>sp</strong> object to see what kind of object we’ve just created.</p>
<pre class="r"><code>class(sac.metro.tracts.sp)</code></pre>
<pre><code>## [1] &quot;SpatialPolygonsDataFrame&quot;
## attr(,&quot;package&quot;)
## [1] &quot;sp&quot;</code></pre>
<p>We find out that <em>sac.metro.tracts.sp</em> is a <strong>SpatialPolygonsDataFrame</strong> object. <strong>SpatialPolygonsDataFrame</strong> objects are almost like regular R data frames. However, unlike an <strong>sf</strong> spatial object, the attribute and feature data in an <strong>sp</strong> object are stored separately in what are known as <a href="https://stat.ethz.ch/R-manual/R-devel/library/methods/html/slot.html">data slots</a>. To see the complexity of data slots, do a <code>View()</code> of the data set</p>
<pre class="r"><code>View(sac.metro.tracts.sp)</code></pre>
<p>Delving into the feature data slot reveals a series of nested lists and S4 objects, which can be confusing to work with directly. We won’t go into the messy details of <strong>sp</strong> objects and how they differ from <strong>sf</strong> objects. We’ll stick with <strong>sf</strong> objects when possible, but shift to <strong>sp</strong> when needed, dancing around the details as much as possible and only talking about them when necessary. If you are interested, you can learn more about the <strong>sp</strong> package <a href="https://cran.r-project.org/web/packages/sp/vignettes/intro_sp.pdf">here</a>, <a href="https://cran.r-project.org/web/packages/sp/vignettes/over.pdf">here</a> and <a href="http://www.nickeubank.com/gis-in-r/">here</a>.</p>
<div style="margin-bottom:25px;">

</div>
</div>
<div id="wednesday-lecture-setup" class="section level2">
<h2><strong>Wednesday lecture setup</strong></h2>
<p><br />
We went through spatial data wrangling operations during Monday’s lecture. Using these operations, we created a spatial dataset containing census tracts within the Sacramento metropolitan area. Let’s now use that dataset to calculate the spatial autocorrelation of percent foreign born.</p>
<p>First, install the following packages if you have not already done so (we did this during Monday’s lecture)</p>
<pre class="r"><code>install.packages(&quot;sp&quot;)
install.packages(&quot;spdep&quot;)</code></pre>
<p>If you get the question “Do you want to install from sources the package which needs compilation?”, type in “no” and press return/enter.</p>
<p>Next, load the following packages</p>
<pre class="r"><code>library(tidyverse)
library(sf)
library(tmap)
library(sp)
library(spdep)</code></pre>
<p>Next, bring into R the Sacramento metropolitan area tract shapefile that we created on Monday. For your convenience, I uploaded the file onto GitHub and you can download it onto your hard drive using the following code.</p>
<pre class="r"><code>download.file(url = &quot;https://raw.githubusercontent.com/crd150/data/master/week5wedfiles.zip&quot;, destfile = &quot;week5wedfiles.zip&quot;)
unzip(zipfile = &quot;week5wedfiles.zip&quot;)</code></pre>
<p>Read the shapefile into R using <code>st_read()</code>.</p>
<pre class="r"><code>sac.metro.tracts.w &lt;- st_read(&quot;sacmetrotractsw.shp&quot;, stringsAsFactors = FALSE)</code></pre>
<p>There are two census tracts with zero population. An example of a zero population tract would be something like an airport or a tract located within a state or national forest. Because nobody lives there, let’s take these tracts out using the <code>filter()</code> function.</p>
<pre class="r"><code>sac.metro.tracts.w &lt;- filter(sac.metro.tracts.w, totp != 0)</code></pre>
<p>Now convert <em>sac.metro.tracts.w</em> to an <strong>sp</strong> object, which we need to do because the remaining functions in this lab only work with <strong>sp</strong> objects.</p>
<pre class="r"><code>sac.metro.tracts.sp &lt;- as(sac.metro.tracts.w, &quot;Spatial&quot;)</code></pre>
<p><em>sac.metro.tracts.w</em> contains percent foreign born and total population for tracts in the Sacramento metropolitan area. <em>sac.metro.tracts.sp</em> is the <strong>sp</strong> version of <em>sac.metro.tracts.w</em>. Go through the first half of the lab to determine how these objects were created.</p>
<div style="margin-bottom:25px;">

</div>
</div>
<div id="spatial-autocorrelation" class="section level2">
<h2><strong>Spatial autocorrelation</strong></h2>
<p><br />
Our next goal is to determine whether the foreign-born population in Sacramento geographically clusters. Let’s focus on the Sacramento metropolitan area. We can explore clustering by examining maps and scatterplots. We can also formally test for clustering by calculating the Moran’s I, which was covered in OSU Ch. 7.</p>
<div style="margin-bottom:25px;">

</div>
<div id="exploratory-mapping" class="section level3">
<h3><strong>Exploratory mapping</strong></h3>
<p><br />
Before computing spatial autocorrelation, you should map your variable to see if it <em>looks</em> like it clusters across space. Using the function <code>tm_shape()</code> and the mapping principles we learned in last week’s lecture, let’s make a nice map showing the proportion (or percent) foreign-born in the Sacramento metro area using quantile breaks.</p>
<pre class="r"><code>tm_shape(sac.metro.tracts.w, unit = &quot;mi&quot;) +
  tm_polygons(col = &quot;pfb&quot;, style = &quot;quantile&quot;,palette = &quot;Reds&quot;, 
              border.alpha = 0, title = &quot;&quot;) +
  tm_scale_bar(breaks = c(0, 10, 20), size = 1) +
  tm_compass(type = &quot;4star&quot;, position = c(&quot;left&quot;, &quot;bottom&quot;)) + 
  tm_layout(main.title = &quot;Percent foreign-born in Sacramento Metropolitan Area 
            Tracts&quot;,  main.title.size = 0.95, frame = FALSE)</code></pre>
<p><img src="lab5_files/figure-html/unnamed-chunk-30-1.png" /><!-- --></p>
<p>It does look like the foreign-born population clusters. In particular, there appears to be high concentrations of foreign-born residents in South and North Sacramento city and the more fringe areas of the metro in the North.</p>
<div style="margin-bottom:25px;">

</div>
</div>
<div id="spatial-weights-matrix" class="section level3">
<h3><strong>Spatial weights matrix</strong></h3>
<p><br />
Before we can formally model the spatial dependency shown in the above map, we must first cover how neighborhoods are spatially connected to one another. That is, what does “near” mean when we say “near things are more related than distant things”? You need to define</p>
<ol style="list-style-type: decimal">
<li>Neighbor connectivity (who is you neighbor?)</li>
<li>Neighbor weights (how much does your neighbor matter?)</li>
</ol>
<p>The functions we will use below are specific to <strong>sp</strong> objects. As a general rule, we’ll stick with our <strong>sf</strong> object <em>sac.metro.tracts.w</em> when possible, but shift to <em>sac.metro.tracts.sp</em> when needed.</p>
<div style="margin-bottom:25px;">

</div>
<div id="neighbor-connectivity" class="section level4">
<h4><strong>Neighbor connectivity</strong></h4>
<p><br />
A common way of defining neighbors is to see who shares a border. The two most common ways of defining contiguity is Rook and Queen adjacency (Figure 3). Rook adjacency refers to neighbors that share a line segment. Queen adjacency refers to neighbors that share a line segment (or border) or a point (or vertex).</p>
<center>
<div class="figure">
<img src="fig1.png" alt="Figure 3: Geographic contiguity" />
<p class="caption">Figure 3: Geographic contiguity</p>
</div>
</center>
<p>Neighbor relationships in R are represented by neighbor <em>nb</em> objects. An <em>nb</em> object identifies the neighbors for each feature in the dataset. We use the command <code>poly2nb()</code> from the <strong>spdep</strong> package to create a contiguity-based neighbor object.</p>
<p>Let’s specify Queen connectivity. The function <code>poly2nb()</code> only takes in <strong>sp</strong> objects, so we’ll need to use <em>sac.metro.tracts.sp</em> here.</p>
<pre class="r"><code>sacb&lt;-poly2nb(sac.metro.tracts.sp, queen=T)</code></pre>
<p>You plug the object <em>sac.metro.tracts.sp</em> into the first argument of <code>poly2nb()</code> and then specify Queen contiguity using the argument <code>queen=T</code>. To get Rook adjacency, change the argument to <code>queen=F</code>.</p>
<p>The function <code>summary()</code> tells us something about the neighborhood.</p>
<pre class="r"><code>summary(sacb)</code></pre>
<p>The average number of neighbors (adjacent polygons) is 6.3, 1 polygon has 1 neighbor and 1 has 18 neighbors.</p>
<div style="margin-bottom:25px;">

</div>
</div>
<div id="neighbor-weights" class="section level4">
<h4><strong>Neighbor weights</strong></h4>
<p><br />
We’ve established who our neighbors are by creating an <em>nb</em> object. The next step is to assign weights to each neighbor relationship. The weight determines <em>how much</em> each neighbor counts. You will need to employ the <code>nb2listw()</code> command, which will you give you a spatial weights object.</p>
<pre class="r"><code>sacw&lt;-nb2listw(sacb, style=&quot;W&quot;, zero.policy = TRUE)</code></pre>
<p>In the command, you first put in your neighbor <em>nb</em> object (<em>sacb</em>) and then define the weights <code>style = &quot;W&quot;</code>. Here, <code>style = &quot;W&quot;</code> indicates that the weights for each spatial unit are standardized to sum to 1 (this is known as row standardization - see page 49 in OSU). For example, if census tract 1 has 3 neighbors, each of those neighbors will have weights of 1/3. This allows for comparability between areas with different numbers of neighbors.</p>
<p>The <code>zero.policy = TRUE</code> argument tells R to ignore cases that have <strong>no</strong> neighbors. How can this occur? Figure 4 provides an example. It shows tracts in Los Angeles county. You’ll notice two tracts that are not geographically adjacent to other tracts - they are literally islands (Catalina and San Clemente). So, if you specify queen adjacency, these islands would have no neighbors. If you conduct a spatial analysis of Los Angeles county tracts in R, most functions will spit out an error indicating that you have polygons with no neighbors. To avoid that, specify <code>zero.policy = TRUE</code>, which will ignore all cases without neighbors.</p>
<center>
<div class="figure">
<img src="lacounty.png" alt="Figure 4: Los Angeles county tracts" />
<p class="caption">Figure 4: Los Angeles county tracts</p>
</div>
</center>
<div style="margin-bottom:25px;">

</div>
</div>
</div>
<div id="moran-scatterplot" class="section level3">
<h3><strong>Moran Scatterplot</strong></h3>
<p><br />
We’ve now defined what we mean by neighbor by creating an <em>nb</em> object and the influence of each neighbor by creating a spatial weights matrix. The map of percent foreign born showed that neighborhood percent foreign born appears to be clustered in Sacramento. We can visually explore this a little more by plotting percent foreign-born on the x-axis and the average percent foreign born of one’s neighbors (also known as the spatial lag) on the y-axis. This plot is known as a Moran scatterplot.</p>
<p>You can create a Moran scatterplot using the function <code>moran.plot()</code>.</p>
<pre class="r"><code>moran.plot(sac.metro.tracts.sp$pfb, sacw,
           xlab = &quot;% foreign born&quot;,
           ylab = &quot;Neighbors % foreign born&quot;)</code></pre>
<p><img src="lab5_files/figure-html/unnamed-chunk-34-1.png" /><!-- --></p>
<p>The first argument is the variable you want to calculate spatial autocorrelation for. Because we are in the <strong>sp</strong> world, which is not tidy friendly, we refer to variables in <em>sac.metro.tracts.sp</em>’s using the dollar sign <code>$</code>. <em>sac.metro.tracts.sp$pfb</em> will give you the percent foreign born as a vector.</p>
<pre class="r"><code>sac.metro.tracts.sp$pfb</code></pre>
<p>The second argument is the spatial weights matrix that defines neighbor and interaction. The <code>xlab</code> and <code>ylab</code> arguments provides clean labels for the x and y axes.</p>
<p>The x-axis is a tract’s percent foreign born and the y-axis is the average percent foreign born of that tract’s neighbors. Looks like a fairly strong positive association - the higher your neighbors’ percent foreign born, the higher your own neighborhood’s percent foreign born. As we discussed in lecture, you can separate the plot into four quadrants based on positive and negative spatial autocorrelation.</p>
<div style="margin-bottom:25px;">

</div>
</div>
<div id="morans-i" class="section level3">
<h3><strong>Moran’s I</strong></h3>
<p><br />
The map and Moran scatterplot provide descriptive visualizations of spatial clustering (autocorrelation) in the percent foreign born. But, rather than eyeballing the correlation, we need a quantitative and objective approach to measuring the degree to which places cluster. This is where measures of spatial autocorrelation step in. An index of spatial autocorrelation provides a summary over the entire study area of the level of spatial similarity observed among neighboring observations.</p>
<p>The most popular test of spatial autocorrelation is the Moran’s I test. Use the command <code>moran.test()</code> in the <strong>spdep</strong> package to calculate the Moran’s I.</p>
<pre class="r"><code>moran.test(sac.metro.tracts.sp$pfb, sacw)    </code></pre>
<pre><code>## 
##  Moran I test under randomisation
## 
## data:  sac.metro.tracts.sp$pfb  
## weights: sacw    
## 
## Moran I statistic standard deviate = 23.926, p-value &lt; 2.2e-16
## alternative hypothesis: greater
## sample estimates:
## Moran I statistic       Expectation          Variance 
##      0.6255551789     -0.0020703934      0.0006881139</code></pre>
<p>We find that the Moran’s I is positive (0.63) and statistically significant (p-value &lt; 0.05). Remember from lecture that the Moran’s I is simply a correlation, and we learned from Handout 3 that correlations go from -1 to 1. A 0.63 correlation is fairly high (meeting the rule of thumb of 0.30 that OSU states on page 206), indicating strong positive clustering. Moreover, we find that this correlation is statistically significant (p-value basically at 0).</p>
<hr />
<p><a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc/4.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">Creative Commons Attribution-NonCommercial 4.0 International License</a>.</p>
<p>Website created and maintained by <a href="https://nbrazil.faculty.ucdavis.edu/">Noli Brazil</a></p>
</div>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open')
  });
});
</script>

<!-- code folding -->
<script>
$(document).ready(function () {
  window.initializeCodeFolding("show" === "show");
});
</script>

<script>
$(document).ready(function ()  {

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_').toLowerCase();
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>


</body>
</html>
